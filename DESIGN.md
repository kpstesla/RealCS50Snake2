

Kyle Whitecross
5/8/18

The basic design of my project is simple-- using natural selection to "evolve" a neural network to play the old video game snake.  However, when broken down into individual tasks it became very complicated.  To abstract this complexity, I took full advantage of Java's object oriented system to break up big tasks into smaller ones.  

The first and most basic class in my program is Matrix.java, which is essentially a wrapper class for a 2D array of doubles.  It has basic static methods to add, subtract, and multiply matrices, as well as more specialized methods to use in a neural network.  It has a method that applies the sigmoid function (f(x) = 1 / (1 + e^-x)) to every value in the matrix to "squish" each value to between 0 and 1.  In addition, it utilizes a "merge" method, that accepts two matrices and row and column numbers as parameters, and returns a new matrix that contains the part of the first matrix up to the row and column number, and the part of the second matrix to the end.  This is especially useful for the genetic algorithm, as it allows two "parent" networks to merge their "genes" in the form of matrices to create a new and unique "child" network.  Finally, Matrix.java also contains many basic mutator and accessor methods.

The next class in the project is the Network.java class, a very simple and flexible neural network class.  It consists of multiple layers of densely connected neurons, and takes in an input Matrix and outputs an Output matrix.  A network is first created with an array of integers and mean and standard deviation values.  The array of integers represents the number of layers and the number of neurons in each layer.  For example, the array [8,16,4] would create a network with 8 input neurons, a hidden layer of 16 neurons, and an output layer of 4 neurons.  Each weight and bias for each neuron is then generated randomly according to the mean and standard deviation parameters.  The main method used in the Network.java class is the feedforward method, which takes a Matrix of inputs, and sends them through the network and outputs a Matrix corresponding to the activation values of the output layer of neurons.  The network class also includes a method to randomly mutate some of its values (to increase genetic variation) according to a mutation chance parameter, and a method to cross all of its parameters over with another network, to create a "child" network that is a hybrid of both of its parents.  Finally the Network.java class also implements Comparable so it can be sorted in an ArrayList according to its fitness value.

The next class in my project is the Snake.java class, which creates the snake game and is used to evaluate networks.  Snake is a very simple video game where a player maneuvers a line to collect dots on a grid (board).  As the player collects more dots, (often called cherries) the snake grows in length.  If the snake touches the edges of the grid, or comes into contact with itself, it dies and the game ends.  The challenge grows as the snake grows longer and longer and it becomes more difficult to navigate around the screen without dying.  

I chose snake as the video game to train a neural network on because of its simplicity and popularity.  A network playing snake would only need to decide one of three things at any point during the game: do I turn left, do I turn right, or do I continue going straight?  Also, the board is simple to view and there are many different ways to show it to the network.  The Snake.java class first constructs a board according to given parameters, and randomly places the head of the snake and the cherry on the board.  Then, it repeats a few methods until the game is over.  First, it updates the board as a 2D array of integers, where each integer represents the state of that spot on the board (0 = nothing, 1 = part of the snake, 2 = cherry, 3 = board edge), then it calculates a "features" matrix and feeds that through the neural network to get a direction the network wants to move in.  The snake then moves and the cherry is randomly placed if it is eaten, and the game checks to see if it is over.  If the game ends, the fitness value of the network that played it is updated, and the game stops.  

The features matrix is a representation of how the snake should see the board and what it can make decisions based on.  First, I intended to show the snake the entire board, but then realized that would require a very large and complicated neural network, which would evolve incredibly slowly (if at all).  Also, it would mean that a network trained on that board could only play on that specific size board, which would prevent it from playing on other sized boards.  Instead, I decided to show the snake an 8x1 matrix that told it where it could go, and in which direction the cherry was.  This way, the snake would get almost the same level of information, would be much simpler and faster to learn, and able to play on any size board.  The specific values in the features matrix are labelled in the getFeatures method of the Snake.java class.  The fitness value is the critical value used to evaluate the overall success of a network at playing snake; how "fit" and good at "surviving" it is. It is stored in each network as a local variable.  It is calculated as the weighted sum of the number of moves the snake made towards the cherry, the number of moves the snake made away from the cherry, and the number of cherries it ate.  The weights can be changed in the hyper parameters section of GeneticAlgorithm.java, as they produce different results with different values.

The SuperSnakeLoader.java class is a utility class responsible for saving and loading networks to and from a file so they can be used multiple times.  Since evolution is random, and not every run of the program will result in a network that is good at playing snake, it is useful to be able to save them to a file so they are not lost.  SuperSnakeLoader.java uses first takes a network and converts it into a single string, containing all of the relevant values of the network it a specific order.  Since different networks will have different lengths, it uses certain characters to dynamically separate certain values (the order and characters used are specified in the class).  Once the network is parsed as a String, a BufferedFileWriter is used to open the file and append the network to it.  Networks are separated by '\n' characters so that multiple can be stored in the same file.  To load a file, a BufferedFileReader is used to get the String that represents the network, then the data values are stored in local variables.  Finally, a new network is created, and its relevant data is set to be the data from the local variables so the new network is identical to the old network.  I chose to use Strings and .txt files because of their simplicity and user-friendliness.  Although it probably would have been more efficient to store the values in a pure binary file, that would have taken significantly more time to develop and debug.  SuperSnakeLoader.class also has several methods that return the best network, a list of all of the networks above a certain fitness level, and networks with a specific architecture.

The GeneticAlgorithm.java class is the main class of the project, as it brings all of the other projects together.  It is highly configurable, and each unique configuration yields different results.  First it declares 20 different hyper parameters, parameters which control lots of smaller parameters.  To make the program more user friendly, all of the hyper parameters are displayed and annotated when the program is run.  Then, it creates a List of networks called a population and fills it up with randomly generated networks according to the parameters.  If enabled, snakes stored in a file ("super snakes") can be loaded and added into the initial population.  This can help to "jumpstart" the evolution of the population as it enhances the gene pool.  The program iterates through every network and has it play snake, updating every network's fitness value.  Then, the population is organized by fitness value in descending order.  A certain amount at the end is then deleted, to represent how only the fittest networks survive.  The remaining networks then pair up and crossover a certain amount of times to restore the population.  To make sure that there is genetic diversity, every network then may have some of its values mutated according to the global mutation chance.  Mutation also ensures that if a beneficial gene is not present in a population, then there is a chance it will be added to the population through mutation.  Then the average fitness, the highest fitness, and the generation number are displayed on the console log.  This process (called a generation) is repeated until the best network has a fitness score above the target fitness, the fitness the GeneticAlgorithm is trying to reach.  To ensure that the high fitness score was not just random luck, the network that received the score above the target then plays multiple more snake games to calculate is average fitness.  If the average fitness is above a threshold, then it can be saved to a file (if that is enabled in the hyper parameters).  If the average is still above the target fitness, then the process stops repeating, and the successful network plays a game that is displayed to the screen so the user can see it.  One major problem with the class is that as the population becomes more fit, and survives longer in each game of snake, it takes longer for each generation to run.  In addition, after a certain number of generations the average fitness of the generations begins to plateau off, and stop increasing.  To prevent the program from running forever, the thread will eventually stop once the maximum number of generations has been reached and display the best network of the last generation playing a game.  

Finally, the Demo.java class is a simple program to demonstrate the most fit networks playing snake in a graphical form.  It first plays a game with the best network that has been saved, and then it plays a certain number of games with random networks selected from the specified file.  It is meant only to demonstrate that a genetic algorithm can be used to evolve a neural network that is pretty good at playing snake.

